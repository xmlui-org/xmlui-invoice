<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Load SQL.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <script>
        // Global database variables
        let DB = null;
        let API_ROUTES = null;
        let API_REQUESTS_QUEUE = [];
        let DB_INITIALIZED = false;

        // Helper functions
        window.coalesce = function(value, defaultValue = '') {
          return value ?? defaultValue;
        }

        window.formatMonth = function(month) {
            console.log('formatMonth');
            // Input: '2022-06'
            const [year, monthNum] = month.split('-');
            const date = new Date(year, monthNum - 1);
            return date.toLocaleString('default', { month: 'short', year: '2-digit' });
            // Output: 'Jun 22'
        }

        window.formatToday = function (plusDays = 0) {
            const date = new Date();
            if (plusDays !== 0) {
                date.setDate(date.getDate() + plusDays);
            }
            return date.toISOString().slice(0, 10).replace(/-/g, '/');
        }

        // Initialize the SQLite database
        async function initDatabase() {
            try {
                // Initialize SQL.js
                const SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });

                // Load database file
                const dbResponse = await fetch('data.db');
                const dbBuffer = await dbResponse.arrayBuffer();
                DB = new SQL.Database(new Uint8Array(dbBuffer));
                console.log('SQLite database loaded successfully');

                // Load API routes
                const apiResponse = await fetch('sql/api.json');
                API_ROUTES = await apiResponse.json();
                console.log('API routes loaded successfully');

                // Set up fetch interceptor
                setupFetchInterceptor();

                // Mark as initialized
                DB_INITIALIZED = true;

                // Process any queued requests
                processQueuedRequests();
            } catch (error) {
                console.error('Error initializing database:', error);
            }
        }

        // Process any API requests that were queued while initializing
        function processQueuedRequests() {
            while (API_REQUESTS_QUEUE.length > 0) {
                const { url, options, resolve, reject } = API_REQUESTS_QUEUE.shift();
                console.log('Processing queued request:', url);
                handleApiRequest(url, options).then(resolve).catch(reject);
            }
        }

        // Set up fetch interceptor
        function setupFetchInterceptor() {
            const originalFetch = window.fetch;

            window.fetch = function(resource, options = {}) {
                const url = resource instanceof Request ? resource.url : resource;

                // Only intercept requests to the API endpoints
                if (url.includes('/api/')) {
                    console.log('Intercepting API request:', url);

                    // If database is not initialized yet, queue the request
                    if (!DB_INITIALIZED) {
                        console.log('Database not initialized yet, queuing request:', url);
                        return new Promise((resolve, reject) => {
                            API_REQUESTS_QUEUE.push({ url, options, resolve, reject });
                        });
                    }

                    return handleApiRequest(url, options);
                }

                // For all other requests, use the original fetch
                return originalFetch.apply(this, arguments);
            };
        }

        // Handle API requests
        async function handleApiRequest(url, options = {}) {
            try {
                // Find matching endpoint in API routes
                const parsedUrl = new URL(url, window.location.origin);
                const endpoint = findMatchingEndpoint(parsedUrl.pathname);

                if (!endpoint) {
                    console.error('No matching endpoint found for:', parsedUrl.pathname);
                    return createResponse({ error: 'Endpoint not found' }, 404);
                }

                // Get the HTTP method
                const method = options.method || 'GET';

                // Find the method definition for the endpoint
                const methodDef = endpoint.methods[method];

                if (!methodDef) {
                    console.error(`Method ${method} not supported for endpoint ${endpoint.path}`);
                    return createResponse({ error: `Method ${method} not supported` }, 405);
                }

                // Extract parameters from the URL and request body
                const params = extractParams(parsedUrl, endpoint.path, options);

                // Execute the SQL query
                const result = executeQuery(methodDef, params);

                // Return the response
                return createResponse(result);
            } catch (error) {
                console.error('Error handling API request:', error);
                return createResponse({ error: error.message }, 500);
            }
        }

        // Find matching endpoint in API routes
        function findMatchingEndpoint(urlPath) {
            if (!API_ROUTES || !API_ROUTES.endpoints) {
                return null;
            }

            // Remove API base path
            const apiBasePath = API_ROUTES.basePath || '/api';
            let pathToMatch = urlPath;

            if (urlPath.startsWith(apiBasePath)) {
                pathToMatch = urlPath.substring(apiBasePath.length) || '/';
            }

            // Find exact match first
            let endpoint = API_ROUTES.endpoints.find(e => e.path === pathToMatch);

            if (endpoint) {
                return endpoint;
            }

            // Try to match pattern with parameters
            for (const e of API_ROUTES.endpoints) {
                const routeParts = e.path.split('/').filter(p => p !== '');
                const urlParts = pathToMatch.split('/').filter(p => p !== '');

                // Skip if different number of parts (excluding empty parts)
                if (routeParts.length !== urlParts.length) {
                    continue;
                }

                let isMatch = true;

                for (let i = 0; i < routeParts.length; i++) {
                    if (routeParts[i].startsWith(':')) {
                        // This is a parameter, it will match anything
                        continue;
                    }

                    if (routeParts[i] !== urlParts[i]) {
                        isMatch = false;
                        break;
                    }
                }

                if (isMatch) {
                    return e;
                }
            }

            return null;
        }

        // Extract parameters from the URL and request body
        function extractParams(urlObj, routePath, options) {
            const params = {};

            // Extract URL parameters
            const urlPath = urlObj.pathname;
            const apiBasePath = API_ROUTES.basePath || '/api';
            const pathWithoutBase = urlPath.startsWith(apiBasePath)
                ? urlPath.substring(apiBasePath.length)
                : urlPath;

            const routeParts = routePath.split('/').filter(p => p !== '');
            const urlParts = pathWithoutBase.split('/').filter(p => p !== '');

            for (let i = 0; i < routeParts.length; i++) {
                if (i < urlParts.length && routeParts[i].startsWith(':')) {
                    // Extract parameter name without the colon
                    const paramName = routeParts[i].substring(1);
                    // Decode URL parameters to handle spaces and special characters
                    params[paramName] = decodeURIComponent(urlParts[i]);
                }
            }

            // Extract query parameters
            for (const [key, value] of urlObj.searchParams.entries()) {
                params[key] = value;
            }

            // Extract body parameters if present
            if (options.body) {
                try {
                    const bodyParams = JSON.parse(options.body);
                    Object.assign(params, bodyParams);
                } catch (e) {
                    console.warn('Failed to parse request body:', e);
                }
            }

            return params;
        }

        // Execute SQL query
        function executeQuery(methodDef, params) {
            console.log('query', methodDef.sql, params);
            
            if (!DB) {
                throw new Error('Database not initialized');
            }

            try {
                let processedSql = methodDef.sql;
                let sqlParams = [];

                // For queries with a params list in methodDef, ensure correct parameter order
                if (methodDef.params && Array.isArray(methodDef.params) && methodDef.params.length > 0) {
                    // Add parameters in the correct order as specified in the API definition
                    for (const paramName of methodDef.params) {
                        sqlParams.push(params[paramName]);
                    }
                    
                    // Rebuild the SQL with '?' placeholders in order
                    processedSql = methodDef.sql;
                    for (const paramName of methodDef.params) {
                        // Replace the named parameter with ? placeholder
                        const paramRegex = new RegExp(':' + paramName + '\\b', 'g');
                        processedSql = processedSql.replace(paramRegex, '?');
                    }
                } else {
                    // Fallback to original parameter extraction logic
                    // Check if we have parameters in the SQL query
                    const paramRegex = /[:$](\w+)/g;
                    let match;
                    let paramPositions = [];
                    
                    while ((match = paramRegex.exec(methodDef.sql)) !== null) {
                        paramPositions.push({
                            name: match[1],
                            position: match.index,
                            fullMatch: match[0]
                        });
                    }
                    
                    // Sort parameters by position (descending) to avoid affecting other replacements
                    paramPositions.sort((a, b) => b.position - a.position);
                    
                    for (const param of paramPositions) {
                        const paramName = param.name;
                        const paramValue = params[paramName];
                        
                        if (paramValue !== undefined) {
                            // Add parameter to the list
                            sqlParams.push(paramValue);
                            
                            // Replace named parameter with ? placeholder
                            processedSql = processedSql.substring(0, param.position) + 
                                          '?' + 
                                          processedSql.substring(param.position + param.fullMatch.length);
                        }
                    }
                }

                // Execute the query
                let results;
                
                // For debugging: Show SQL with parameters substituted
                let debugSql = processedSql;
                sqlParams.forEach((param, index) => {
                    debugSql = debugSql.replace('?', typeof param === 'string' ? `'${param}'` : param);
                });
                console.log('Debug SQL (with params):', debugSql);

                if (sqlParams.length > 0) {
                    // Use prepared statement for queries with parameters
                    const stmt = DB.prepare(processedSql);

                    if (processedSql.trim().toUpperCase().startsWith('SELECT')) {
                        // For SELECT queries, return the results
                        stmt.bind(sqlParams);
                        results = [];

                        while (stmt.step()) {
                            results.push(stmt.getAsObject());
                        }
                    } else {
                        // For INSERT, UPDATE, DELETE queries
                        stmt.run(sqlParams);
                        results = { changes: DB.getRowsModified() };
                    }

                    stmt.free();
                } else {
                    // For queries without parameters, use exec
                    const execResults = DB.exec(processedSql);

                    if (execResults && execResults.length > 0) {
                        // Convert column/value format to array of objects
                        results = [];
                        const columns = execResults[0].columns;
                        const values = execResults[0].values;

                        for (const row of values) {
                            const obj = {};
                            for (let i = 0; i < columns.length; i++) {
                                obj[columns[i]] = row[i];
                            }
                            results.push(obj);
                        }
                    } else {
                        // No results returned (for INSERT, UPDATE, DELETE)
                        results = { changes: DB.getRowsModified() };
                    }
                }

                return results;
            } catch (error) {
                console.error('SQL execution error:', error);
                throw error;
            }
        }

        // Create a Response object
        function createResponse(data, status = 200) {
            console.log('results', data)
            return new Response(JSON.stringify(data), {
                status: status,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }

        // Initialize the database before rendering
        document.addEventListener('DOMContentLoaded', initDatabase);
    </script>
    <script src="xmlui/0.9.23.js"></script>
    <script src="xmlui/charts-0.1.12.js"></script>
</head>

<body></body>

</html>
